#!/usr/bin/env python3

import sys
import os
import glob
from itertools import islice, chain
try:
    import requests
except:
    print("ERROR - You need to install requests: pip install requests")
    # TODO python 3.5
    sys.exit(-1)

assert sys.version_info[0] == 3, "This script requires Python 3"


# CHANGE TO YOUR INSTALLATION'S URL INCLUDING THE PORT NUMBER -- Example: http://localhost:9000/
__default_domain__ = "https://www.tagtog.net/"

__author__ = "tagtog (@tagtog_net) - Contact: Juan Miguel Cejuela (@juanmirocks)"
__version__ = "0.0.1"
__doc__ = \
    """
    Script to upload files (and folders' files) to tagtog.

    Example call: 'tagtog upload --user demo --project demo file folder another_file ...'

    Version: {}
    Author: {}
    API documentation: https://github.com/tagtog/tagtog-doc/wiki/API-documents-v0.1
    """.format(__version__, __author__)


def parse_arguments(argv=[]):
    import argparse
    import getpass

    parser = argparse.ArgumentParser(description=__doc__)

    # Future-proof for other possible actions
    parser.add_argument("action", choices=["upload"], help="Action to execute -- Only 'upload' is possible")
    if argv[0] != "upload":
        print("ERROR the first argument must be 'upload'")
        sys.exit(-1)
    # TODO add functionality for download

    parser.add_argument("--domain", default=__default_domain__, help="tagtog domain, e.g. http://localhost:9000/")
    parser.add_argument("--entrypoint", default="api/0.1/documents")

    parser.add_argument('--user', required=True, help="tagtog username making the request")
    parser.add_argument('--password', required=False, default=None, help="User's password -- if not given, the password is prompted")
    parser.add_argument("--owner", required=False, help="Owner of the project to upload the files to -- Defaults to the user")
    parser.add_argument("--project", required=True, help="Project name to upload the files to")

    parser.add_argument("--output", default="null", help="Output type to get from tagtog's response")

    parser.add_argument("paths", nargs='+', help="paths of files or folders containing (recursively) the files to upload")

    args = parser.parse_args(argv)

    if not args.domain.endswith("/"):
        args.domain += "/"

    if args.password is None:
        args.password = getpass.getpass(prompt="tagtog password: ")

    if args.owner is None:
        args.owner = args.user

    args.req_url = args.domain + args.entrypoint
    args.req_auth = requests.auth.HTTPBasicAuth(username=args.user, password=args.password)
    args.password = None  # Hide
    args.req_params = {"owner": args.owner, "project": args.project, "output": args.output}

    return args


def upload(args, filepath_iterator):
    BATCH_SIZE = 2

    batch_index = 0
    while True:
        batch_index += 1
        batch = islice(filepath_iterator, BATCH_SIZE)
        first = next(batch, None)
        if first is None:
            return
        else:
            batch = chain([first], batch)

        files = []
        for filepath in batch:
            files.append(("files", open(filepath, "rb")))

        response = requests.put(args.req_url, params=args.req_params, auth=args.req_auth, files=files)
        print("batch", batch_index, response, response.text)
        if response != 200:
            # TODO allow for next batches to continue ?
            return


def gen_filepaths_generator(paths):
    generator = []
    for path in paths:
        generator = chain(generator, gen_filespath_generator(path))
    return generator


def gen_filespath_generator(path):
    if os.path.isfile(path):
        return [path]
    elif os.path.isdir(path):
        return (subpath for subpath in glob.iglob(path + "/**", recursive=True) if os.path.isfile(subpath))
    else:
        print("warning, cannot read:", path)
        return []  # resilient


if __name__ == "__main__":
    args = parse_arguments(sys.argv[1:])
    print("Uploading documents to:", args.domain)
    print()

    files_to_upload = gen_filepaths_generator(args.paths)
    upload(args, files_to_upload)
